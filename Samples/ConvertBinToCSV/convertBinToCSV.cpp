/*
  * This example demonstrates how to convert the bin file to CSV file.
  * The bin file is generated by CeleX5 sensor.
  * The CSV file includes the frame data of the bin file.
  * The frame data includes the frame number, the frame time, the frame type,
  the
  * event data, the optical-flow data, the full-frame data, etc.


  Usage: convertBinToCSV [bin file path] [csv file path]

*/

#include <fstream>
#include <vector>

#ifdef _WIN32
#include <windows.h>
#else
#include <unistd.h>
#endif

#include <celex5/celex5.h>
#include <celex5/celex5datamanager.h>
#include <celex5/celex5processeddata.h>
#include <opencv2/opencv.hpp>

class SensorDataObserver : public CeleX5DataManager {
  public:
    SensorDataObserver(CX5SensorDataServer *pServer, CeleX5 *pCeleX5) {
        m_pServer = pServer;
        m_pCeleX5 = pCeleX5;
        m_pServer->registerData(this, CeleX5DataManager::CeleX_Frame_Data);
    }

    ~SensorDataObserver() { m_pServer->unregisterData(this, CeleX5DataManager::CeleX_Frame_Data); }

    virtual void onFrameDataUpdated(CeleX5ProcessedData *pSensorData); // overrides Observer operation

    CX5SensorDataServer *m_pServer;
    CeleX5 *m_pCeleX5;
};

std::ofstream csv_file;
uint8_t *pImageBuffer = new uint8_t[CELEX5_PIXELS_NUMBER];
uint8_t *pImageBufferAlt = new uint8_t[CELEX5_PIXELS_NUMBER];
std::vector<EventData> events{};

void SensorDataObserver::onFrameDataUpdated(CeleX5ProcessedData *pSensorData) {
    if (NULL == pSensorData)
        return;
    CeleX5::CeleX5Mode sensorMode = pSensorData->getSensorMode();
    if (CeleX5::Full_Picture_Mode == sensorMode) {
        // Full-Frame picture
        m_pCeleX5->getFullPicBuffer(pImageBuffer);
        cv::Mat matFullPic(800, 1280, CV_8UC1, pImageBuffer);
        cv::imshow("FullPic", matFullPic);
        cv::waitKey(1);
    } else if (CeleX5::Event_Off_Pixel_Timestamp_Mode == sensorMode) {
        // Get buffers when sensor works in EventMode
        m_pCeleX5->getEventPicBuffer(pImageBuffer, CeleX5::EventBinaryPic);
        cv::Mat matEventPic(800, 1280, CV_8UC1, pImageBuffer);
        cv::imshow("Event Binary Pic", matEventPic);
        cv::waitKey(1);
    } else if (CeleX5::Optical_Flow_Mode == sensorMode) {
        // Full-Frame optical-flow pic
        m_pCeleX5->getOpticalFlowPicBuffer(pImageBuffer, CeleX5::OpticalFlowPic);
        cv::Mat matOpticalFlow(800, 1280, CV_8UC1, pImageBuffer);
        cv::imshow("Optical-Flow Pic", matOpticalFlow);
        cv::waitKey(1);
    } else if (CeleX5::Event_Intensity_Mode == sensorMode) {
        // Get buffers when sensor works in FullPic_Event_Mode
        m_pCeleX5->getEventPicBuffer(pImageBuffer, CeleX5::EventBinaryPic);
        m_pCeleX5->getEventPicBuffer(pImageBufferAlt, CeleX5::EventGrayPic);
        m_pCeleX5->getEventDataVector(events);
        for (auto event : events) {
            if (event.polarity == 0)
                continue;
            csv_file << event.tOffPixelIncreasing << "," << event.col << "," << (800 - event.row) << ","
                     << (event.polarity == 1 ? 1 : 0) << "\n";
        }
    }
}

int main(int argc, char *argv[]) {
    if (argc < 3) {
        std::cout << "Usage: convertBinToCSV [bin file path] [csv file path]\n";
        return 0;
    }

    const std::string binFilePath = argv[1];
    const std::string csvFilePath = argv[2];

    auto pCeleX5 = new CeleX5;
    if (!pCeleX5->openBinFile(binFilePath)) {
        std::cerr << "Failed to open bin file: " << binFilePath << std::endl;
        return 0;
    }

    csv_file.open(csvFilePath);
    if (!csv_file.is_open()) {
        std::cerr << "Failed to create csv file: " << csvFilePath << std::endl;
        return 0;
    }

    SensorDataObserver sensorData(pCeleX5->getSensorDataServer(), pCeleX5);

    csv_file << "timestamp,x,y,polarity\n";
    while (true) {
        if (pCeleX5->readBinFileData()) {
            break;
        }
#ifdef _WIN32
        Sleep(1);
#else
        usleep(1000);
#endif
    }
    csv_file.close();

    return 0;
}
